Come up with efficient data structures to represent both types of
images: those generated by the microscope, and those generated by the dye
sensor.  These need not have the same representation; the only requirement is
that they be compact and take as little storage space as possible.  Explain why
you picked the representation you did for each image type, and if possible
estimate how much storage would be taken by the images.  What is the worst-case
storage size in bytes for each image representation you chose?


For the microscope image: we will make the assumption that there is only one contiguous shape in the microcope's focus. This means that if we store the border of the microorganism, we will be able to replicate the image. The way we can define the border of this object is by declaring all white pixels whose edge or corner is touching a black pixel as part of a border. The reason why we need the corner pixels is as follows: if we store "diagonals" (e.g. storing (1, 1) and (2, 2) as 2 consecutive border pixels), it would be logically ambiguous whether the pixels whose edges are touching both border pixels are within or not within the border (e.g. (1, 2) and (2, 1) are unclear whether they are part of the border or not). However, storing each coordinate of each border pixel is very memory intensive, and there is a much more compact way of storing the border than this. If we have a starting position and a closed walk of the border, we can replicate the border perfectly. 

This circuit in implementation would be expressed using an array of unsigned chars, with values assigned to the first four digits of whether the next step in the walk should go up, right, down, or left. To store the starting position, we will use two integers, one for the X axis and one for the Y axis. This means that the size of the file depends on the length of the perimeter of the microorganism.

We know that the microbe has to take up at least 25% of the image. A circle with a radius of 28,210 pixels has an area of 1/4 of the frame size, and the circumference of this circle is 177,250 pixels. Because we're storing this border in pixels (approximating this circle with squares slightly increases the number of necessary pixels), the images are going to be larger than 25% of the total area, and the microbes will not be perfect circles, the perimeter of the object is going to be larger than 177,250 pixels. Although we don't have any sample data to base this off of, I believe a reasonable assumption would be that the average number of pixels in the border would be around 350,000 pixels. There is 1 unsigned char per pixel, 2 integers for the starting position, and 1 pointer for the array. 1 unsigned char = 1 byte, 1 integer = 4 bytes, and 1 pointer = 8 bytes. 350,000 unsigned chars * 1 byte/unsigned char + 2 integers * 4 bytes/integer + 1 pointer * 8 bytes/pointer = 350,000 bytes + 8 bytes + 8 bytes = 350,016 bytes, or about 350 kilobytes. 

Hypothetically, the worst case scenario that I can think of would be if there was a thin comb-like microbe where the bottom row is all white pixels, and there were alternating columns of white and black pixels for the length of the image. Believe it or not, topographically this is technically a single object! Every white pixel on the image would be counted twice in our closed walk (each column would need to be traversed up and down, and the bottom row would need to be traversed from left to right to get to every column, and then from right to left to get back to the beginning). The bottom row would be 100,000 pixels, and there would be 99,999 pixels to every column, meaning there would be 99,999 pixels/column * 50,000 columns = 4,999,950,000 pixels for all the columns. Overall, the object would be 5000050000 pixels total. Because each pixel is counted twice, there would be approximately 10000100000 chars in our array = 10000100000 bytes. Adding the 16 bytes of the other data that we'd need, in total, the worst case scenario would take 10000100016 bytes, which is approximately 10 GB. 



For the dye sensor image: we have no idea how many different contiguous objects there are, and since the dye is going through veins, the perimeter to area ratio of each contiguous object is going to be much larger than that of the microorganism. Therefore, storing the border of each object is going to result in a very convoluted, messy data structure. Instead, since this is another binary image (every pixel either is lit up or isn't), we can keep track row by row how many of each pixel type is in a row. We can start this for each row by listing how many black pixels there are, then the number of dye pixels, then the number of black pixels, then the number of dye pixels, etc. If there are n switches between dye and no dye in a row, then we only need to store the first n integers, as the n+1 integer can be derived by subtracting 100,000 from the sum of the past n number of pixels. For example, in a row if there are 40,000 black pixels, then 20,000 dye pixels, then 40,000 black pixels, our data stored for that row would look like [40000, 20000], as the last 40,000 figure can be derived from subtracting 100,000 from the sum of that array. To save more space, we can have an integer which stores the index of the first row to contain a dye value, as it is unlikely that there is dye contained in the top of the image. In addition, to save even more space, we can keep storing rows until there is no more red dye sensed, so that we won't store empty array values for the bottom fourth of the image. 

Therefore, our data structure will look like this: we will have an object with a vector matrix of integers, and an integer to keep track of what row we start on.

Since we know that only ~.1% of the microorganisms have 10% of their area filled in with cancer, we can assume that the average % of dye found in every microorganism is very low. However, we cannot rely on this figure for an average, as there is dye outside of the microorganisms to account for. If we assume that the average leak of dye is 1/10th the height of an average organism, and that each of the organisms have 1% of their body indicated with dye, we can come up with a relatively accurate estimate. Let's say we position the leak of the dye at 45 degrees from the horizontal line of the center of the organism, and position the 1% of dye in every organism in the very center of the organism. The average height of the organism is going to be larger than 28,210 * 2 pixels, or 56420 pixels, so let's just say 65,000 pixels is the average height. 1/10th of this height would be 6,500 pixels, by using 45/45/90 triangles, we know that the difference in height between the center and 45 degrees from the center is 32500/sqrt(2) = 22,981 pixels, plus roughly 3/4 of the height (it's at an angle from the microbe) of the leaked dye = 4875 pixels, 22,981 + 4875 = 27856 pixels of height we need to keep track of from the center down. However, this doesn't account for the height of the 1% of the cancer dye detection. Since these are in veins and aren't concentrated around a single point, we can't assume anything about it's position, so we can make another estimate that it starts around 1/3 of the way down the cell on average. Therefore, we need to account for 1/6 of the pixels from the center, upwards. 1/6 of 65000 = 10834 pixels, so the total average amount of rows in our matrix will be 10834 + 22981 = 33815 pixels. Whew.

From here, we can assume that there are 33,815 rows in our vector matrix. Each row can be assumed to have an average of 4 values (5 switches), so we will need 33,815 * 4 = 135260 integers. 4 bytes/integer * 135260 = 541,040 bytes. 1 more integer for the row start index, and we come up with 541,044 bytes in total for this data structure.

A worst case scenario would be if there were a grid of dye pixels; if every pixel across a row alternated between dye and no dye. This means 100,000 integers would be stored for each row, for 100,000 rows, meaning there would be 1,000,000,000 integers in total used to store this value. Multiplying this by 4 bytes/integer results in 4,000,000,000 bytes used in total. 

TODO:
things to change:
    explain diagonals better
    explain 45 degree thing better
    reword reasoning for chars
    reexplain stuff w/ context of vectors